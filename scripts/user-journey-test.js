#!/usr/bin/env node

/**
 * üß™ USER JOURNEY TEST 360¬∞ - VoiceCoop
 * 
 * Test complet du parcours utilisateur :
 * - Navigation homepage
 * - Inscription/Connexion
 * - Dashboard access
 * - Fonctionnalit√©s principales
 * - Responsive design
 */

import { chromium } from 'playwright';

class UserJourneyTester {
  constructor() {
    this.browser = null;
    this.page = null;
    this.baseUrl = process.env.TEST_URL || 'https://voicecoop.netlify.app';
    this.results = {
      passed: [],
      failed: [],
      warnings: []
    };
  }

  /**
   * Lance tous les tests
   */
  async runAllTests() {
    console.log('üß™ D√âMARRAGE DES TESTS PARCOURS UTILISATEUR 360¬∞\n');
    console.log(`üåê URL de test: ${this.baseUrl}\n`);
    
    try {
      await this.setupBrowser();
      
      // Tests par ordre de priorit√©
      await this.testHomepageLoad();
      await this.testHomepageButtons();
      await this.testResponsiveDesign();
      await this.testRegistrationFlow();
      await this.testLoginFlow();
      await this.testDashboardAccess();
      await this.testSecurityHeaders();
      await this.testPerformance();
      
      await this.generateReport();
      
    } catch (error) {
      console.error('‚ùå Erreur lors des tests:', error);
      this.results.failed.push(`Erreur critique: ${error.message}`);
    } finally {
      await this.cleanup();
    }
  }

  /**
   * Configuration du navigateur
   */
  async setupBrowser() {
    console.log('üöÄ Configuration du navigateur...');
    
    this.browser = await chromium.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    this.page = await this.browser.newPage();
    
    // Configuration des timeouts
    this.page.setDefaultTimeout(30000);
    this.page.setDefaultNavigationTimeout(30000);
    
    // √âcouter les erreurs console
    this.page.on('console', msg => {
      if (msg.type() === 'error') {
        this.results.warnings.push(`Console Error: ${msg.text()}`);
      }
    });
    
    // √âcouter les erreurs de r√©seau
    this.page.on('response', response => {
      if (response.status() >= 400) {
        this.results.warnings.push(`HTTP ${response.status()}: ${response.url()}`);
      }
    });
  }

  /**
   * Test de chargement de la homepage
   */
  async testHomepageLoad() {
    console.log('üè† Test de chargement de la homepage...');
    
    try {
      const startTime = Date.now();
      await this.page.goto(this.baseUrl);
      const loadTime = Date.now() - startTime;
      
      // V√©rifier le titre
      const title = await this.page.title();
      if (title.includes('VoiceCoop') || title.includes('Create Next App')) {
        this.results.passed.push('‚úÖ Homepage charg√©e avec titre correct');
      } else {
        this.results.failed.push(`‚ùå Titre incorrect: ${title}`);
      }
      
      // V√©rifier le temps de chargement
      if (loadTime < 5000) {
        this.results.passed.push(`‚úÖ Temps de chargement acceptable: ${loadTime}ms`);
      } else {
        this.results.warnings.push(`‚ö†Ô∏è Temps de chargement lent: ${loadTime}ms`);
      }
      
      // V√©rifier la pr√©sence d'√©l√©ments cl√©s
      const heroTitle = await this.page.locator('h1').first().isVisible();
      if (heroTitle) {
        this.results.passed.push('‚úÖ Titre principal visible');
      } else {
        this.results.failed.push('‚ùå Titre principal manquant');
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur chargement homepage: ${error.message}`);
    }
  }

  /**
   * Test des boutons de la homepage
   */
  async testHomepageButtons() {
    console.log('üîò Test des boutons de la homepage...');
    
    try {
      // Test bouton "Commencer" dans le header
      const headerButton = this.page.locator('header').locator('text=Commencer').first();
      if (await headerButton.isVisible()) {
        this.results.passed.push('‚úÖ Bouton "Commencer" header visible');
        
        // V√©rifier le lien
        const href = await headerButton.getAttribute('href');
        if (href && href.includes('/auth/register')) {
          this.results.passed.push('‚úÖ Bouton "Commencer" header bien configur√©');
        } else {
          this.results.failed.push('‚ùå Bouton "Commencer" header mal configur√©');
        }
      } else {
        this.results.failed.push('‚ùå Bouton "Commencer" header manquant');
      }
      
      // Test bouton "Connexion"
      const loginButton = this.page.locator('text=Connexion').first();
      if (await loginButton.isVisible()) {
        this.results.passed.push('‚úÖ Bouton "Connexion" visible');
      } else {
        this.results.failed.push('‚ùå Bouton "Connexion" manquant');
      }
      
      // Test bouton "Voir la d√©mo"
      const demoButton = this.page.locator('text=Voir la d√©mo').first();
      if (await demoButton.isVisible()) {
        this.results.passed.push('‚úÖ Bouton "Voir la d√©mo" visible');
      } else {
        this.results.failed.push('‚ùå Bouton "Voir la d√©mo" manquant');
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur test boutons: ${error.message}`);
    }
  }

  /**
   * Test du design responsive
   */
  async testResponsiveDesign() {
    console.log('üì± Test du design responsive...');
    
    const viewports = [
      { name: 'Mobile', width: 375, height: 667 },
      { name: 'Tablet', width: 768, height: 1024 },
      { name: 'Desktop', width: 1920, height: 1080 }
    ];
    
    for (const viewport of viewports) {
      try {
        await this.page.setViewportSize({ width: viewport.width, height: viewport.height });
        await this.page.waitForTimeout(1000);
        
        // V√©rifier que le contenu est visible
        const heroVisible = await this.page.locator('h1').first().isVisible();
        if (heroVisible) {
          this.results.passed.push(`‚úÖ ${viewport.name} (${viewport.width}px): Contenu visible`);
        } else {
          this.results.failed.push(`‚ùå ${viewport.name}: Contenu non visible`);
        }
        
        // V√©rifier l'absence de scroll horizontal
        const bodyWidth = await this.page.evaluate(() => document.body.scrollWidth);
        if (bodyWidth <= viewport.width + 20) { // Marge de 20px
          this.results.passed.push(`‚úÖ ${viewport.name}: Pas de scroll horizontal`);
        } else {
          this.results.warnings.push(`‚ö†Ô∏è ${viewport.name}: Scroll horizontal d√©tect√©`);
        }
        
      } catch (error) {
        this.results.failed.push(`‚ùå Erreur responsive ${viewport.name}: ${error.message}`);
      }
    }
    
    // Remettre en desktop
    await this.page.setViewportSize({ width: 1920, height: 1080 });
  }

  /**
   * Test du flow d'inscription
   */
  async testRegistrationFlow() {
    console.log('üìù Test du flow d\'inscription...');
    
    try {
      // Naviguer vers la page d'inscription
      await this.page.goto(`${this.baseUrl}/auth/register`);
      
      // V√©rifier que la page se charge
      const pageTitle = await this.page.locator('h1, h2').first().textContent();
      if (pageTitle && (pageTitle.includes('Inscription') || pageTitle.includes('Register') || pageTitle.includes('Cr√©er'))) {
        this.results.passed.push('‚úÖ Page d\'inscription accessible');
      } else {
        this.results.failed.push('‚ùå Page d\'inscription non accessible ou mal configur√©e');
        return;
      }
      
      // V√©rifier la pr√©sence du formulaire
      const emailField = this.page.locator('input[type="email"], input[name="email"]').first();
      const passwordField = this.page.locator('input[type="password"], input[name="password"]').first();
      const submitButton = this.page.locator('button[type="submit"], button:has-text("Inscription"), button:has-text("S\'inscrire")').first();
      
      if (await emailField.isVisible()) {
        this.results.passed.push('‚úÖ Champ email pr√©sent');
      } else {
        this.results.failed.push('‚ùå Champ email manquant');
      }
      
      if (await passwordField.isVisible()) {
        this.results.passed.push('‚úÖ Champ mot de passe pr√©sent');
      } else {
        this.results.failed.push('‚ùå Champ mot de passe manquant');
      }
      
      if (await submitButton.isVisible()) {
        this.results.passed.push('‚úÖ Bouton de soumission pr√©sent');
      } else {
        this.results.failed.push('‚ùå Bouton de soumission manquant');
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur test inscription: ${error.message}`);
    }
  }

  /**
   * Test du flow de connexion
   */
  async testLoginFlow() {
    console.log('üîê Test du flow de connexion...');
    
    try {
      await this.page.goto(`${this.baseUrl}/auth/login`);
      
      // V√©rifier que la page se charge
      const pageTitle = await this.page.locator('h1, h2').first().textContent();
      if (pageTitle && (pageTitle.includes('Connexion') || pageTitle.includes('Login') || pageTitle.includes('Se connecter'))) {
        this.results.passed.push('‚úÖ Page de connexion accessible');
      } else {
        this.results.failed.push('‚ùå Page de connexion non accessible');
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur test connexion: ${error.message}`);
    }
  }

  /**
   * Test d'acc√®s au dashboard
   */
  async testDashboardAccess() {
    console.log('üìä Test d\'acc√®s au dashboard...');
    
    try {
      await this.page.goto(`${this.baseUrl}/dashboard`);
      
      // Le dashboard devrait rediriger vers login si non connect√©
      await this.page.waitForTimeout(2000);
      const currentUrl = this.page.url();
      
      if (currentUrl.includes('/auth/login') || currentUrl.includes('/auth/')) {
        this.results.passed.push('‚úÖ Dashboard prot√©g√© - redirection vers login');
      } else if (currentUrl.includes('/dashboard')) {
        this.results.warnings.push('‚ö†Ô∏è Dashboard accessible sans authentification');
      } else {
        this.results.failed.push('‚ùå Comportement inattendu pour l\'acc√®s dashboard');
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur test dashboard: ${error.message}`);
    }
  }

  /**
   * Test des headers de s√©curit√©
   */
  async testSecurityHeaders() {
    console.log('üõ°Ô∏è Test des headers de s√©curit√©...');
    
    try {
      const response = await this.page.goto(this.baseUrl);
      const headers = response.headers();
      
      const securityHeaders = [
        'x-frame-options',
        'x-content-type-options',
        'x-xss-protection',
        'referrer-policy'
      ];
      
      for (const header of securityHeaders) {
        if (headers[header]) {
          this.results.passed.push(`‚úÖ Header de s√©curit√© pr√©sent: ${header}`);
        } else {
          this.results.warnings.push(`‚ö†Ô∏è Header de s√©curit√© manquant: ${header}`);
        }
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur test headers: ${error.message}`);
    }
  }

  /**
   * Test de performance
   */
  async testPerformance() {
    console.log('‚ö° Test de performance...');
    
    try {
      const startTime = Date.now();
      await this.page.goto(this.baseUrl);
      await this.page.waitForLoadState('networkidle');
      const totalTime = Date.now() - startTime;
      
      if (totalTime < 3000) {
        this.results.passed.push(`‚úÖ Performance excellente: ${totalTime}ms`);
      } else if (totalTime < 5000) {
        this.results.warnings.push(`‚ö†Ô∏è Performance acceptable: ${totalTime}ms`);
      } else {
        this.results.failed.push(`‚ùå Performance lente: ${totalTime}ms`);
      }
      
    } catch (error) {
      this.results.failed.push(`‚ùå Erreur test performance: ${error.message}`);
    }
  }

  /**
   * G√©n√®re le rapport final
   */
  async generateReport() {
    console.log('\n' + '='.repeat(60));
    console.log('üìä RAPPORT DE TEST PARCOURS UTILISATEUR 360¬∞');
    console.log('='.repeat(60));
    
    console.log(`\n‚úÖ TESTS R√âUSSIS (${this.results.passed.length}):`);
    this.results.passed.forEach(test => console.log(test));
    
    console.log(`\n‚ùå TESTS √âCHOU√âS (${this.results.failed.length}):`);
    this.results.failed.forEach(test => console.log(test));
    
    console.log(`\n‚ö†Ô∏è AVERTISSEMENTS (${this.results.warnings.length}):`);
    this.results.warnings.forEach(warning => console.log(warning));
    
    // Score global
    const totalTests = this.results.passed.length + this.results.failed.length;
    const successRate = totalTests > 0 ? Math.round((this.results.passed.length / totalTests) * 100) : 0;
    
    console.log(`\nüéØ TAUX DE R√âUSSITE: ${successRate}%`);
    
    if (this.results.failed.length === 0) {
      console.log('\nüéâ TOUS LES TESTS SONT PASS√âS !');
      process.exit(0);
    } else {
      console.log('\n‚ùå CERTAINS TESTS ONT √âCHOU√â');
      process.exit(1);
    }
  }

  /**
   * Nettoyage
   */
  async cleanup() {
    if (this.browser) {
      await this.browser.close();
    }
  }
}

// Ex√©cution des tests
const tester = new UserJourneyTester();
tester.runAllTests().catch(console.error);

export default UserJourneyTester;
